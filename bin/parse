#!/usr/bin/env ruby
# frozen_string_literal: true

$:.unshift(File.expand_path("../lib", __dir__))
require "rubygems"
require "bundler/setup"
require "regular_expression"
require "crabstone"
require "graphviz"

unless `which dot`.chomp.end_with?("dot")
  warn "YOU HAVE NOT INSTALLED GRAPHVIZ. We found no 'dot' in your path.\n" \
       " Please install Graphviz if you want dotfile visual output to work."
end

# Pass the source through the various parsing phases
source = ARGV.shift
ast = RegularExpression::Parser.new.parse(source)
nfa = ast.to_nfa
bytecode = RegularExpression::Bytecode.compile(nfa)

# Compile the graph into various outputs
cfg = RegularExpression::CFG.build(bytecode)
schedule = RegularExpression::Scheduler.schedule(cfg)
ruby = RegularExpression::Compiler::Ruby.compile(cfg, schedule)
x86 = RegularExpression::Compiler::X86.compile(cfg, schedule)

# Make sure we get some nice dot output
RegularExpression::AST.to_dot(ast)
RegularExpression::NFA.to_dot(nfa)
RegularExpression::CFG.to_dot(cfg)

# Dump out the bytecode, cfg and schedule to strings
puts "#{bytecode.dump}\n"
puts "#{cfg.dump}\n"
puts "#{RegularExpression::Scheduler.dump(cfg, schedule)}\n"

check =
  if ARGV.any?
    lambda do |compiled|
      checker = compiled.to_proc
      ARGV.each { |string| puts "#{string}: #{checker.call(string).inspect}" }
      puts
    end
  else
    ->(_compiled) {}
  end

# Test the interpreter against any passed strings
interpreter = RegularExpression::Interpreter.new(bytecode)
check.call(interpreter)

# Dump out the compiled ruby source and match against any passed values
puts "#{ruby.source}\n"
check.call(ruby)

# Dump out the diassembled x86 source and match against any passed values
puts "#{x86.disasm}\n"
check.call(x86)
